byte 能表示最小的範圍，long 能表示最大的範圍
int 是 java whole number 的 default type

| 類型    | 位元數（SIZE） | 範圍                       | 包裝類別    |
| ----- | --------- | ------------------------------ | ------- |
| byte  | 8 bits    | -128 ~ 127                     | Byte    |
| short | 16 bits   | -32,768 ~ 32,767               | Short   |
| int   | 32 bits   | -2,147,483,648 ~ 2,147,483,647 | Integer |
| long  | 64 bits   | -2⁶³ ~ 2⁶³−1                   | Long    |


● Byte

```java
Byte.MAX_VALUE 
Byte.MIN_VALUE 
```

byte 的最小值是 -128，最大值是 127
因為範圍非常小，你實務上通常不會常用 byte
可能唯一會使用 byte 的情況是，你真的需要儲存大量且範圍很小的數字
想節省記憶體或提升效能
此外，使用 byte 也可以用來表達「我只預期數字會落在這個範圍內」，這對閱讀程式碼的人而言是一種紀錄或說明

● Short

```java
Short.MAX_VALUE 
Short.MIN_VALUE 
```

short 最小值是 -32768
最大值是 32767，範圍比 byte 大，但比 int 小

byte 與 short 都會有跟 int 相同的 overflow（溢位）與 underflow（下溢）問題只是範圍不同
如果把會超過 127 的運算結果存到 byte，就會變成負數


● 記憶體大小（width）

每種資料型別佔用的記憶體空間：

byte：8 bits，可表示 256 個數字

short：16 bits

int：32 bits

long：64 bits

Wapper Class 也提供 SIZE 屬性 , 例如 Integer.SIZE，可以用來查該型別使用的 bit 數

● Long

```java
long myLongValue = 100;
```

雖然能運作，嚴格來說不算精準，因為 100 預設是 int某些情況下

Java 允許在數字後面加上後綴來代表資料型別

而 long 使用的是 L

大小寫都可以

建議使用大寫 L，以免看起來像數字 1

```java
long myLongValue = 100L;
```

我們也能透過：
```java
Long.SIZE
```

取得 long 的 bits 寬度（64 bits）

● long 能儲存的數值範圍，相較於 int 到底大多少？

兩者之間的差距相當巨大
long 資料型別能表示非常大的數值範圍
它也同樣存在我們之前討論過的 overflow（溢位）與 underflow（下溢）問題



● 小的可以自動變大（int → long）
```java
long myLongValue = 100;
```
嘗試把數值 100 指派給一個 long 型別的變數，但不使用 L 後綴
這樣能成功的原因是：int 的範圍一定可以放進 long 型別
因為 long 的位元寬度是 int 的兩倍
Java 會自動把 int 轉成 long，而不是丟出錯誤


● 如果我們嘗試輸入一個「超過 int 能處理範圍」的數值，又沒有加上 L 後綴，就會產生錯誤

我們知道之前曾使用過 int 的最大值，並把它指派給一個 int 變數

因此，先從這個數字開始，並將它指派給一個新的 long 變數：
```java
long bigLongLiteralValue = 2_147_483_647;
```

我們知道這是 int 的最大值

接著我們把這個數字再加大一點，在最後加上 _234：
```java
long bigLongLiteralValue = 2_147_483_647_234;
```

這時就會出現錯誤：「Integer number too large」

這很清楚地表示，Java 仍然把這個數字當作 int 來處理

任何超過 Integer.MAX_VALUE 的數值 literal，都必須使用 L 後綴

只要我們在數字後面加上 L：
```java
long bigLongLiteralValue = 2_147_483_647_234L;
```
這個數字就能被接受
而且可以看到剛剛加上的 234 也還在

● 從 int 轉換成更小型別（例如 short）」時的行為

Java 會檢查你要使用的數值 literal，是否能放進 short 型別

```java
short bigShortLiteralValue = 32_768;
```
錯誤訊息指出：「 incompatible types」
指說需要的是 short，但找到的是 int
而且這個 int 的值超過 short 所能表示的最大值（32767）

如果我們把最後一個數字改成 7：
```java
short bigShortLiteralValue = 32_767;
```
錯誤就消失了
Java 很樂意讓你把這個預設為 int 的數字 literal 指派給 short 變數
因為它確實在 short 可容納的範圍內