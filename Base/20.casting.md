型別轉換（casting）

讓 Java 把某一種型別的變數，當成另一種型別來處理的方法

●  Java 程式碼中，什麼時候以及為什麼需要使用 casting
- 我們非常確定這個運算結果一定能放進 某個數值 type，使用 `casting` 讓 Java 知道

```java
short myMinShortValue = Short.MIN_VALUE;

int myMinIntValue = Integer.MIN_VALUE;
```

```java
byte myMinByteValue = Byte.MIN_VALUE, myMaxByteValue = Byte.MAX_VALUE;
```

在同一個敘述中宣告多個變數是有一些規則的
1. 你`不能`在同一個敘述中宣告不同資料型別的變數
如果你在同一個敘述中宣告多個相同資料型別的變數
資料型別只能在最前面寫一次

錯誤示範
```java
short firstShort = 1, int firstInteger = 2;
```

2. 第二個規則，同一個敘述中`不能`宣告兩個相同型別的變數：
```java
byte firstByte = 1, byte secondByte = 2;
```
你可以看到這同樣出現了錯誤，錯誤訊息也是「identifier expected」

● 算數
```java
int myTotal = (myMinIntValue / 2);
```
以上整個過程完全沒有任何問題

改用 byte
```java
byte myNewByteValue = (myMinByteValue / 2);
```
! 報錯了 ！
我們知道這個除法運算的結果應該是在 byte 的範圍之內 怎麼會報錯呢

實際發生的是：
```java
byte myMinByteValue = -128;

(myMinByteValue / 2)   // Java：這是 int，不是 byte
```
-> 結果型別是 int
-> 但你卻要指派給 byte

```java
byte myNewByteValue = (int結果); // ❌ int → byte（縮小轉型）
```
!! Java 不允許你「自動」把大的型別塞進小的型別 !!


myNewByteValue 是變數
如果你的計算只使用常數（literal values）
Java 就可以在編譯時直接算出結果，並判斷它是否能放進該變數型別中
如果可以，就不會丟出錯誤
```java
byte myNewByteValue  = (-128 / 2) 
```

我們非常確定這個運算結果一定能放進 byte
怎麼讓 Java 知道？
這時就要用到 casting

誤消失了
因為我們使用了這個 cast
告訴 Java：請把這個值當成 byte
而不是預設的 int
```java
byte myNewByteValue = (byte) (myMinByteValue / 2);
```

雖然我們可以使用 casting
建議是：`除非你有非常明確的理由，否則請一律使用 int`